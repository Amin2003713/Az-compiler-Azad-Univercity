{
  واحد: SyntaxLine
  توضیحات:
  این واحد شامل ساختار TSyntaxLine است که برای پردازش متنی به منظور تحلیل سینتکس طراحی شده است.
  این ساختار شامل عملیاتی مانند خواندن فایل، پیمایش در متن، بررسی پایان فایل و گزارش خطاهای سینتکس به همراه اطلاعات دقیق می‌باشد.

  توسعه‌دهنده: mohhamad amin ahmadi
  تاریخ: 2025-02-21
}

unit SyntaxLine;

interface

uses
  Dialogs, SysUtils, IOUtils, Character, Types, Generics.Collections;

type
  TSyntaxLine = record
  private const
    END_OF_FILE_CHAR = #1; // نشانگر انتهای فایل
  private
    FSourceText: string; // متن اصلی مورد پردازش
    FCurrentPos: Integer; // موقعیت فعلی در متن
    FNewPosition: Integer; // موقعیت ثانویه (برای استفاده‌های آینده)
    FLineColumn: TPoint; // موقعیت فعلی به صورت (خط، ستون)؛ X: خط، Y: ستون
  public
    /// <summary>
    /// تمام فیلدهای داخلی را به حالت اولیه بازنشانی می‌کند.
    /// </summary>
    procedure Reset;

    /// <summary>
    /// متن ورودی را تنظیم کرده و نشانگر انتهای فایل را به آن اضافه می‌کند.
    /// </summary>
    procedure SetSourceText(const AText: string);

    /// <summary>
    /// متن منبع را از فایل مشخص شده بارگذاری می‌کند و نشانگر انتهای فایل را به آن اضافه می‌کند.
    /// </summary>
    procedure LoadFromFile(const AFileName: string);

    /// <summary>
    /// موقعیت فعلی را به APos تغییر می‌دهد، اطلاعات خط و ستون را به‌روزرسانی کرده و متنی شامل کاراکترهای طی شده برمی‌گرداند.
    /// </summary>
    function MoveToPosition(APos: Integer): string;

    /// <summary>
    /// در صورت رسیدن به پایان متن یا مشاهده نشانگر انتهای فایل، مقدار True برمی‌گرداند.
    /// </summary>
    function IsEndOfFile: Boolean;

    /// <summary>
    /// خط جاری متن را با توجه به وجود کاراکترهای newline استخراج و برمی‌گرداند.
    /// </summary>
    function GetCurrentLine: string;

    /// <summary>
    /// در صورت بروز خطای سینتکس، پیام خطا به همراه اطلاعات خط، کاراکتر و موقعیت فعلی نمایش داده و اجرای برنامه متوقف می‌شود.
    /// </summary>
    procedure ReportSyntaxError(const Msg: string);
  end;

implementation

{ TSyntaxLine }

procedure TSyntaxLine.Reset;
begin
  // بازنشانی تمامی فیلدهای داخلی به حالت اولیه
  FSourceText := '';
  FCurrentPos := 0;
  FNewPosition := 0;
  FLineColumn := Point(0, 0);
end;

procedure TSyntaxLine.SetSourceText(const AText: string);
begin
  // بازنشانی و تنظیم متن همراه با افزودن نشانگر انتهای فایل
  Reset;
  FSourceText := AText + END_OF_FILE_CHAR;
  FCurrentPos := 1;
  FNewPosition := 1;
end;

procedure TSyntaxLine.LoadFromFile(const AFileName: string);
var
  Directory, FileToSearch, FileFound: string;
  Files: TStringDynArray;
  I: Integer;
begin
  // Reset any internal state
  Reset;

  // Extract the directory and file name
  Directory := ExtractFilePath(AFileName);
  FileToSearch := ExtractFileName(AFileName);
  if Directory = '' then
    Directory := GetCurrentDir;

  // Enumerate all files in the directory
  Files := TDirectory.GetFiles(Directory);
  FileFound := '';
  for I := 0 to High(Files) do
  begin
    // Compare file names ignoring case
    if SameText(ExtractFileName(Files[I]), FileToSearch) then
    begin
      FileFound := Files[I];
      Break;
    end;
  end;

  // If a matching file was found, load it; otherwise raise an exception
  if FileFound <> '' then
    FSourceText := TFile.ReadAllText(FileFound) + END_OF_FILE_CHAR
  else
    raise Exception.Create('فایل یافت نشد: ' + AFileName);

  FCurrentPos := 1;
  FNewPosition := 1;
end;

function TSyntaxLine.MoveToPosition(APos: Integer): string;
var
  TextBuilder: TStringBuilder;
begin
  TextBuilder := TStringBuilder.Create;
  try
    // پیمایش از موقعیت فعلی تا APos و به‌روزرسانی اطلاعات خط و ستون
    while FCurrentPos < APos do
    begin
      TextBuilder.Append(FSourceText[FCurrentPos]);
      if FSourceText[FCurrentPos] = #10 then
      begin
        Inc(FLineColumn.X); // افزایش شماره خط
        FLineColumn.Y := 1; // بازنشانی شماره ستون به 1
      end
      else
        Inc(FLineColumn.Y); // افزایش شماره ستون
      Inc(FCurrentPos);
    end;
    Result := TextBuilder.ToString;
  finally
    TextBuilder.Free;
  end;
end;

function TSyntaxLine.IsEndOfFile: Boolean;
begin
  // بررسی پایان متن یا رسیدن به نشانگر انتهای فایل
  Result := (FCurrentPos > Length(FSourceText)) or
    (FSourceText[FCurrentPos] = END_OF_FILE_CHAR);
end;

function TSyntaxLine.GetCurrentLine: string;
var
  StartIndex, EndIndex: Integer;
begin
  // تعیین شروع خط جاری با جستجو به عقب تا یافتن کاراکتر newline
  StartIndex := FCurrentPos;
  while (StartIndex > 1) and not(FSourceText[StartIndex - 1] in [#10, #12]) do
    Dec(StartIndex);

  // تعیین پایان خط جاری با جستجو به جلو تا یافتن کاراکتر newline
  EndIndex := FCurrentPos;
  while (EndIndex <= Length(FSourceText)) and
    not(FSourceText[EndIndex] in [#10, #12]) do
    Inc(EndIndex);

  // استخراج و برگرداندن خط جاری از متن
  Result := Copy(FSourceText, StartIndex, EndIndex - StartIndex);
end;

procedure TSyntaxLine.ReportSyntaxError(const Msg: string);
var
  LineInfo, CharInfo, LocInfo: string;
begin
  // ایجاد اطلاعات خطا شامل خط جاری، کاراکتر فعلی و موقعیت (خط، ستون)
  LineInfo := 'خط = ' + GetCurrentLine;
  CharInfo := 'کاراکتر = ' + FSourceText[FCurrentPos];
  LocInfo := 'موقعیت = (' + FLineColumn.X.ToString + ' , ' +
    FLineColumn.Y.ToString + ')';

  // نمایش پیام خطا به کاربر
  MessageDlg(Msg + sLineBreak + sLineBreak + LineInfo + sLineBreak + CharInfo +
    sLineBreak + LocInfo, mtError, [mbOK], 0);
  Abort;
end;

end.
