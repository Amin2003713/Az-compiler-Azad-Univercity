Index: UiClassic.pas
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>unit UiClassic;\r\n\r\ninterface\r\n\r\nuses\r\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,\r\n  System.Classes, Vcl.Graphics,\r\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls;\r\n\r\ntype\r\n  TFormClassic = class(TForm)\r\n    TopPanel: TPanel;\r\n    LeftPanel: TPanel;\r\n    ClientPanel: TPanel;\r\n    OutputMemo: TMemo;\r\n    InputMemo: TMemo;\r\n    RunBtn: TButton;\r\n    FileCombo: TComboBox;\r\n    SaveBtn: TButton;\r\n    CodeBtn: TButton;\r\n    TranslatorBtn: TButton;\r\n    ParserBtn: TButton;\r\n    DecisionBtn: TButton;\r\n    IrregularBtn: TButton;\r\n    NumBtn: TButton;\r\n    IntBtn: TButton;\r\n    IdBtn: TButton;\r\n    UnreadBtn: TButton;\r\n    StrBtn: TButton;\r\n    procedure OnActivation(Sender: TObject);\r\n    procedure Save(Sender: TObject);\r\n    procedure ChangeFile(Sender: TObject);\r\n    procedure OnRun(Sender: TObject);\r\n    procedure UnreadClicked(Sender: TObject);\r\n    procedure IdClicked(Sender: TObject);\r\n    procedure IntClicked(Sender: TObject);\r\n     procedure NumberClicked(Sender: TObject);\r\n\r\n  private\r\n    { Private declarations }\r\n  public\r\n    { Public declarations }\r\n  end;\r\n\r\nvar\r\n  FormClassic: TFormClassic;\r\n\r\nimplementation\r\n\r\n{$R *.dfm}\r\n\r\nuses SyntaxLine, IOUtils;\r\n\r\nvar\r\n  Inp: TSyntaxLine;\r\n\r\nprocedure TFormClassic.ChangeFile(Sender: TObject);\r\nbegin\r\n  InputMemo.Lines.LoadFromFile(FileCombo.Text);\r\n  Inp.LoadFromFile(FileCombo.Text);\r\nend;\r\n\r\nprocedure TFormClassic.IdClicked(Sender: TObject);\r\nbegin\r\n  Save(Sender);\r\n  OutputMemo.Lines.Text := Inp.SkipId;\r\nend;\r\n\r\nprocedure TFormClassic.IntClicked(Sender: TObject);\r\nbegin\r\n  Save(Sender);\r\n  OutputMemo.Lines.Text := Inp.SkipInt.ToString;\r\nend;\r\n\r\nprocedure TFormClassic.NumberClicked(Sender: TObject);\r\nbegin\r\n  Save(Sender);\r\n  OutputMemo.Lines.Text := Inp.SkipNumber;\r\nend;\r\n\r\nprocedure TFormClassic.OnActivation(Sender: TObject);\r\nvar\r\n  i: Integer;\r\n  F: TArray<String>;\r\nbegin\r\n  F := TDirectory.GetFiles(TDirectory.GetCurrentDirectory, '*.txt');\r\n  for i := 0 to High(F) do\r\n    F[i] := TPath.GetFileName(F[i]);\r\n\r\n  FileCombo.Items.Clear;\r\n  FileCombo.Items.AddStrings(F);\r\n  FileCombo.ItemIndex := 0;\r\n\r\n  InputMemo.Lines.LoadFromFile(FileCombo.Text);\r\n  Inp.LoadFromFile(FileCombo.Text);\r\nend;\r\n\r\nprocedure TFormClassic.OnRun(Sender: TObject);\r\nvar\r\n  SelectedFile: string;\r\nbegin\r\n  // بررسی اینکه آیا فایلی انتخاب شده است\r\n  if FileCombo.Text = '' then\r\n  begin\r\n    ShowMessage('لطفاً یک فایل را انتخاب کنید.');\r\n    Exit;\r\n  end;\r\n\r\n  SelectedFile := FileCombo.Text;\r\n\r\n  Save(Sender);\r\n\r\n  if SelectedFile = 'Unread.txt' then\r\n    UnreadBtn.Click\r\n  else if SelectedFile = 'Id.txt' then\r\n    IdBtn.Click\r\n  else if SelectedFile = 'Int.txt' then\r\n    IntBtn.Click\r\n  else if SelectedFile = 'Num.txt' then\r\n    NumBtn.Click\r\n  else if SelectedFile = 'Str.txt' then\r\n    StrBtn.Click\r\n  else if SelectedFile = 'Irregular.txt' then\r\n    IrregularBtn.Click\r\n  else if SelectedFile = 'Decision.txt' then\r\n    DecisionBtn.Click\r\n  else if SelectedFile = 'Parser.txt' then\r\n    ParserBtn.Click\r\n  else if SelectedFile = 'Translator.txt' then\r\n    TranslatorBtn.Click\r\n  else if SelectedFile = 'Code.txt' then\r\n    CodeBtn.Click\r\n  else\r\n    ShowMessage('دکمه نامعتبر!');\r\nend;\r\n\r\nprocedure TFormClassic.Save(Sender: TObject);\r\nbegin\r\n  if FileCombo.Text = '' then\r\n  begin\r\n    ShowMessage('لطفاً یک فایل را انتخاب کنید.');\r\n    Exit;\r\n  end;\r\n\r\n  try\r\n    InputMemo.Lines.SaveToFile(FileCombo.Text);\r\n    Inp.LoadFromFile(FileCombo.Text);\r\n  except\r\n    on E: Exception do\r\n      ShowMessage('خطا در ذخیره فایل: ' + E.Message);\r\n  end;\r\nend;\r\n\r\nprocedure TFormClassic.UnreadClicked(Sender: TObject);\r\nbegin\r\n  Save(Sender);\r\n  OutputMemo.Lines.Text := Inp.SkipUnread;\r\nend;\r\n\r\nend.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UiClassic.pas b/UiClassic.pas
--- a/UiClassic.pas	(revision e83c5b67b6624f4db1f9e64c15c5bf7be7aa9c19)
+++ b/UiClassic.pas	(date 1740231555066)
@@ -7,6 +7,9 @@
   System.Classes, Vcl.Graphics,
   Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls;
 
+
+
+
 type
   TFormClassic = class(TForm)
     TopPanel: TPanel;
Index: SyntaxLine.pas
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>(*\r\n  Unit: SyntaxLine\r\n  Description:\r\n    This unit defines the TSyntaxLine record used for text processing and syntax analysis.\r\n    It includes methods for:\r\n      - Reading text from a file\r\n      - Navigating through the text\r\n      - Checking for end-of-file conditions\r\n      - Reporting syntax errors with detailed information\r\n\r\n  Developer: mohhamad amin ahmadi\r\n  Date: 2025-02-21\r\n*)\r\n\r\nunit SyntaxLine;\r\n\r\ninterface\r\n\r\nuses\r\n  Dialogs, SysUtils, IOUtils, Character, Types, Generics.Collections;\r\n\r\ntype\r\n  /// <summary>\r\n  /// TSyntaxLine manages a source text for syntax analysis. It supports methods for loading,\r\n  /// scanning, error reporting, and skipping various tokens such as identifiers, integers, and numbers.\r\n  /// </summary>\r\n  TSyntaxLine = record\r\n  private const\r\n    END_OF_FILE_CHAR = #1; // Marker indicating the end of the file\r\n  private\r\n    FSourceText: string;  // The main source text to be processed\r\n    FCurrentPos: Integer; // The current position in the source text\r\n    FNewPosition: Integer; // A secondary position used to mark the end of recognized tokens\r\n    FLineColumn: TPoint;  // Represents the current line (X) and column (Y)\r\n  public\r\n    /// <summary>\r\n    /// Resets all internal fields to their initial states.\r\n    /// </summary>\r\n    procedure Reset;\r\n\r\n    /// <summary>\r\n    /// Sets the input text and appends the end-of-file marker.\r\n    /// </summary>\r\n    procedure SetSourceText(const AText: string);\r\n\r\n    /// <summary>\r\n    /// Loads the source text from the specified file and appends the end-of-file marker.\r\n    /// </summary>\r\n    procedure LoadFromFile(const AFileName: string);\r\n\r\n    /// <summary>\r\n    /// Moves the current position to APos, updates line and column info,\r\n    /// and returns the substring of all characters traversed.\r\n    /// </summary>\r\n    function MoveToPosition(APos: Integer): string;\r\n\r\n    /// <summary>\r\n    /// Returns True if the current position is at or beyond the end of the text\r\n    /// or if the end-of-file marker is encountered.\r\n    /// </summary>\r\n    function IsEndOfFile: Boolean;\r\n\r\n    /// <summary>\r\n    /// Extracts and returns the current line of the text based on newline characters.\r\n    /// </summary>\r\n    function GetCurrentLine: string;\r\n\r\n    /// <summary>\r\n    /// Displays a syntax error message with details about the line, character,\r\n    /// and current position, then aborts execution.\r\n    /// </summary>\r\n    procedure ReportSyntaxError(const Msg: string);\r\n\r\n    /// <summary>\r\n    /// Checks if the remaining text consists only of whitespace or comments.\r\n    /// Returns True if so; otherwise False.\r\n    /// </summary>\r\n    function IsUnread: Boolean;\r\n\r\n    /// <summary>\r\n    /// Skips over any unread text (whitespace/comments) and returns it.\r\n    /// </summary>\r\n    function SkipUnread: string;\r\n\r\n    /// <summary>\r\n    /// Checks if the next sequence of characters forms a valid identifier.\r\n    /// An identifier must start with a letter and may continue with letters or digits.\r\n    /// </summary>\r\n    function IsId: Boolean;\r\n\r\n    /// <summary>\r\n    /// If the next sequence is a valid identifier, skips it and returns the identifier.\r\n    /// Otherwise, reports a syntax error.\r\n    /// </summary>\r\n    function SkipId: string;\r\n\r\n    /// <summary>\r\n    /// Checks if the next sequence of characters forms a valid integer.\r\n    /// Integers may have an optional sign ('-' or '+') followed by one or more digits.\r\n    /// </summary>\r\n    function IsInt: Boolean;\r\n\r\n    /// <summary>\r\n    /// If the next sequence is a valid integer, skips it and returns its integer value.\r\n    /// Otherwise, reports a syntax error.\r\n    /// </summary>\r\n    function SkipInt: Integer;\r\n\r\n    /// <summary>\r\n    /// Checks if the next sequence of characters forms a valid number.\r\n    /// This includes numbers with optional signs, decimal points, and exponents.\r\n    /// </summary>\r\n    function IsNumber: Boolean;\r\n\r\n    /// <summary>\r\n    /// If the next sequence is a valid number, skips it and returns the number as a string.\r\n    /// Otherwise, reports a syntax error.\r\n    /// </summary>\r\n    function SkipNumber: string;\r\n\r\n\r\n\r\n    function IsStr: Boolean;\r\n    function SkipStrQuot: string;\r\n    function SkipStr: string;\r\n  end;\r\n\r\nimplementation\r\n\r\n{ TSyntaxLine }\r\n\r\nfunction TSyntaxLine.SkipId: string;\r\nbegin\r\n  // Skip an identifier token if valid; otherwise, report error.\r\n  if IsId then\r\n    Result := MoveToPosition(FNewPosition)\r\n  else\r\n    ReportSyntaxError('Invalid identifier.');\r\nend;\r\n\r\nfunction TSyntaxLine.SkipInt: Integer;\r\nbegin\r\n  // Skip an integer token if valid; otherwise, report error.\r\n  if IsInt then\r\n    Result := MoveToPosition(FNewPosition).ToInteger\r\n  else\r\n    ReportSyntaxError('Invalid integer.');\r\nend;\r\n\r\nfunction TSyntaxLine.SkipNumber: string;\r\nbegin\r\n  // Skip a number token if valid; otherwise, report error.\r\n  if IsNumber then\r\n    Result := MoveToPosition(FNewPosition)\r\n  else\r\n    ReportSyntaxError('Invalid number.');\r\nend;\r\n\r\nfunction TSyntaxLine.SkipStr: string;\r\nbegin\r\n\r\nend;\r\n\r\nfunction TSyntaxLine.SkipStrQuot: string;\r\nbegin\r\n\r\nend;\r\n\r\nfunction TSyntaxLine.IsId: Boolean;\r\nvar\r\n  p, state: Integer;\r\n  text: Char;\r\nbegin\r\n  // First, skip any unread parts (whitespace/comments)\r\n  SkipUnread;\r\n  state := 0; // Initial state\r\n  // Loop through characters starting at FCurrentPos\r\n  for p := FCurrentPos to High(FSourceText) do\r\n  begin\r\n    text := FSourceText[p];\r\n    case state of\r\n      0:\r\n        // The first character must be a letter\r\n        if text.IsLetter then\r\n          state := 1\r\n        else\r\n          Break;\r\n      1:\r\n        // Subsequent characters can be letters or digits\r\n        if text.IsLetterOrDigit then\r\n          state := 1\r\n        else\r\n          Break;\r\n    end;\r\n  end;\r\n  // Valid identifier if we ended in state 1\r\n  Result := state in [1];\r\n  if Result then\r\n    FNewPosition := p;\r\nend;\r\n\r\nfunction TSyntaxLine.IsInt: Boolean;\r\nvar\r\n  p, state: Integer;\r\n  text: Char;\r\nbegin\r\n  // Skip any unread parts first\r\n  SkipUnread;\r\n  state := 0; // Initial state\r\n  // Loop through the characters to match an integer pattern\r\n  for p := FCurrentPos to High(FSourceText) do\r\n  begin\r\n    text := FSourceText[p];\r\n    case state of\r\n      0:\r\n        // A number may start with a digit or a sign\r\n        if text.IsDigit then\r\n          state := 2\r\n        else if text in ['-', '+'] then\r\n          state := 1\r\n        else\r\n          Break;\r\n      1:\r\n        // After a sign, digits are required\r\n        if text.IsDigit then\r\n          state := 2\r\n        else\r\n          Break;\r\n      2:\r\n        // Continue reading digits\r\n        if text.IsDigit then\r\n          state := 2\r\n        else\r\n          Break;\r\n    end;\r\n  end;\r\n  // Valid integer if state ended in 2\r\n  Result := state in [2];\r\n  if Result then\r\n    FNewPosition := p;\r\nend;\r\n\r\nfunction TSyntaxLine.IsNumber: Boolean;\r\nvar\r\n  p, state: Integer;\r\n  text: Char;\r\nbegin\r\n  // Skip any unread parts first\r\n  SkipUnread;\r\n  state := 0; // Initial state\r\n  // Loop through characters to match number patterns (supports decimal and exponent parts)\r\n  for p := FCurrentPos to High(FSourceText) do\r\n  begin\r\n    text := FSourceText[p];\r\n    case state of\r\n      0:\r\n        // Start with an optional sign or digit\r\n        if text in ['+', '-'] then\r\n          state := 1\r\n        else if text.IsDigit then\r\n          state := 2\r\n        else\r\n          Break;\r\n      1:\r\n        // After a sign, a digit must follow\r\n        if text.IsDigit then\r\n          state := 2\r\n        else\r\n          Break;\r\n      2:\r\n        // Read digits; if a dot or slash (for decimals) or 'E' for exponent is encountered, move to next state\r\n        if text.IsDigit then\r\n          state := 2\r\n        else if text in ['.', '/'] then\r\n          state := 3\r\n        else if text = 'E' then\r\n          state := 5\r\n        else\r\n          Break;\r\n      3:\r\n        // After a decimal point, expect digits\r\n        if text.IsDigit then\r\n          state := 4\r\n        else\r\n          Break;\r\n      4:\r\n        // Continue reading digits after the decimal point; exponent can follow\r\n        if text.IsDigit then\r\n          state := 4\r\n        else if text = 'E' then\r\n          state := 5\r\n        else\r\n          Break;\r\n      5:\r\n        // After 'E', allow an optional sign for the exponent\r\n        if text in ['+', '-'] then\r\n          state := 6\r\n        else if text.IsDigit then\r\n          state := 7\r\n        else\r\n          Break;\r\n      6:\r\n        // After the optional exponent sign, expect digits\r\n        if text.IsDigit then\r\n          state := 7\r\n        else\r\n          Break;\r\n      7:\r\n        // Read the exponent digits\r\n        if text.IsDigit then\r\n          state := 7\r\n        else\r\n          Break;\r\n    end;\r\n  end;\r\n  // The number is valid if we finish in one of these states\r\n  Result := state in [7, 4, 2];\r\n  if Result then\r\n    FNewPosition := p;\r\nend;\r\n\r\nfunction TSyntaxLine.IsStr: Boolean;\r\nbegin\r\n\r\nend;\r\n\r\nfunction TSyntaxLine.SkipUnread: string;\r\nbegin\r\n  // Continuously skip over unread text (whitespace/comments)\r\n  Result := '';\r\n  while IsUnread do\r\n    Result := Result + MoveToPosition(FNewPosition);\r\nend;\r\n\r\n{\r\n  IsUnread checks whether the remaining text in FSourceText\r\n  consists only of whitespace or comments.\r\n\r\n  Comments can be of two forms:\r\n    1. Single-line comment: starts with \"//\" and continues until a newline.\r\n    2. Multi-line comment: starts with \"/*\" and ends with \"*/\".\r\n\r\n  If any non-comment and non-whitespace character is encountered,\r\n  the function stops and returns False.\r\n\r\n  Output:\r\n    - Boolean: True if the unread portion is solely whitespace/comments; otherwise, False.\r\n}\r\nfunction TSyntaxLine.IsUnread: Boolean;\r\nvar\r\n  p, state: Integer;\r\n  text: Char;\r\nbegin\r\n  state := 0; // Initial state\r\n  // Process characters starting at the current position\r\n  for p := FCurrentPos to High(FSourceText) do\r\n  begin\r\n    text := FSourceText[p];\r\n    case state of\r\n      // State 0: Look at the first character\r\n      0:\r\n        if text = '/' then\r\n          state := 1  // Potential start of a comment\r\n        else if text.IsWhiteSpace then\r\n          state := 5  // Whitespace detected\r\n        else\r\n          Break;     // Found a non-whitespace, non-comment character\r\n      // State 1: After seeing '/', decide if it is a single-line or multi-line comment\r\n      1:\r\n        if text = '/' then\r\n          state := 6  // Single-line comment confirmed\r\n        else if text = '*' then\r\n          state := 2  // Multi-line comment confirmed\r\n        else\r\n          Break;     // Not a valid comment start\r\n      // State 2: Inside a multi-line comment\r\n      2:\r\n        if text = '*' then\r\n          state := 3; // Possible end of multi-line comment\r\n        // Otherwise, remain in multi-line comment state\r\n      // State 3: Check if the multi-line comment is ending\r\n      3:\r\n        if text = '*' then\r\n          state := 3  // Still possible end-of-comment sequence\r\n        else if text = '/' then\r\n          state := 4  // End of multi-line comment found\r\n        else\r\n          state := 2; // Return to inside multi-line comment state\r\n      // State 5: In whitespace; continue until a non-whitespace is found\r\n      5:\r\n        if text.IsWhiteSpace then\r\n          state := 5  // Continue in whitespace\r\n        else\r\n          Break;     // Non-whitespace encountered\r\n      // State 6: Inside a single-line comment\r\n      6:\r\n        if text in [#10, #13] then\r\n          state := 7  // End of single-line comment\r\n        else\r\n          state := 6; // Continue reading the single-line comment\r\n      // States 4 and 7 indicate that a comment has ended\r\n      4, 7:\r\n        Break;\r\n    end;\r\n  end;\r\n  // If we ended in state 4 (multi-line comment closed), 5 (whitespace), or 7 (single-line comment ended),\r\n  // then the unread part consists only of comments/whitespace.\r\n  Result := state in [4, 5, 7];\r\n  // Update the new position marker if the result is True\r\n  if Result then\r\n    FNewPosition := p;\r\nend;\r\n\r\nprocedure TSyntaxLine.Reset;\r\nbegin\r\n  // Reset all internal fields to their initial values.\r\n  FSourceText := '';\r\n  FCurrentPos := 0;\r\n  FNewPosition := 0;\r\n  FLineColumn := Point(0, 0);\r\nend;\r\n\r\nprocedure TSyntaxLine.SetSourceText(const AText: string);\r\nbegin\r\n  // Reset the state and set the source text with the end-of-file marker appended.\r\n  Reset;\r\n  FSourceText := AText + END_OF_FILE_CHAR;\r\n  FCurrentPos := 1;\r\n  FNewPosition := 1;\r\nend;\r\n\r\nprocedure TSyntaxLine.LoadFromFile(const AFileName: string);\r\nvar\r\n  Directory, FileToSearch, FileFound: string;\r\n  Files: TStringDynArray;\r\n  I: Integer;\r\nbegin\r\n  // Reset any internal state\r\n  Reset;\r\n\r\n  // Determine the directory and file name from the given path\r\n  Directory := ExtractFilePath(AFileName);\r\n  FileToSearch := ExtractFileName(AFileName);\r\n  if Directory = '' then\r\n    Directory := GetCurrentDir;\r\n\r\n  // Retrieve the list of files in the directory\r\n  Files := TDirectory.GetFiles(Directory);\r\n  FileFound := '';\r\n  // Loop through the files to find a matching file name (case-insensitive)\r\n  for I := 0 to High(Files) do\r\n  begin\r\n    if SameText(ExtractFileName(Files[I]), FileToSearch) then\r\n    begin\r\n      FileFound := Files[I];\r\n      Break;\r\n    end;\r\n  end;\r\n\r\n  // If a matching file was found, read its contents and append the end-of-file marker;\r\n  // otherwise, raise an exception.\r\n  if FileFound <> '' then\r\n    FSourceText := TFile.ReadAllText(FileFound) + END_OF_FILE_CHAR\r\n  else\r\n    raise Exception.Create('File not found: ' + AFileName);\r\n\r\n  FCurrentPos := 1;\r\n  FNewPosition := 1;\r\nend;\r\n\r\nfunction TSyntaxLine.MoveToPosition(APos: Integer): string;\r\nvar\r\n  TextBuilder: TStringBuilder;\r\nbegin\r\n  // Collect characters from the current position up to APos,\r\n  // updating line and column information along the way.\r\n  TextBuilder := TStringBuilder.Create;\r\n  try\r\n    while FCurrentPos < APos do\r\n    begin\r\n      // Append the current character to the result\r\n      TextBuilder.Append(FSourceText[FCurrentPos]);\r\n      // If a newline is encountered, update the line and reset the column\r\n      if FSourceText[FCurrentPos] = #10 then\r\n      begin\r\n        Inc(FLineColumn.X); // Increase the line count\r\n        FLineColumn.Y := 1;  // Reset the column count to 1\r\n      end\r\n      else\r\n        Inc(FLineColumn.Y); // Otherwise, increment the column count\r\n\r\n      Inc(FCurrentPos); // Move to the next character\r\n    end;\r\n    // Return the collected substring\r\n    Result := TextBuilder.ToString;\r\n  finally\r\n    TextBuilder.Free;\r\n  end;\r\nend;\r\n\r\nfunction TSyntaxLine.IsEndOfFile: Boolean;\r\nbegin\r\n  // Check if the current position exceeds the text length or if the next character is the EOF marker.\r\n  Result := (FCurrentPos > Length(FSourceText))\r\n    or (FSourceText[FCurrentPos] = END_OF_FILE_CHAR);\r\nend;\r\n\r\nfunction TSyntaxLine.GetCurrentLine: string;\r\nvar\r\n  StartIndex, EndIndex: Integer;\r\nbegin\r\n  // Determine the start of the current line by scanning backward until a newline is found.\r\n  StartIndex := FCurrentPos;\r\n  while (StartIndex > 1) and not (FSourceText[StartIndex - 1] in [#10, #12]) do\r\n    Dec(StartIndex);\r\n\r\n  // Determine the end of the current line by scanning forward until a newline is found.\r\n  EndIndex := FCurrentPos;\r\n  while (EndIndex <= Length(FSourceText)) and not (FSourceText[EndIndex] in [#10, #12]) do\r\n    Inc(EndIndex);\r\n\r\n  // Return the substring that represents the current line.\r\n  Result := Copy(FSourceText, StartIndex, EndIndex - StartIndex);\r\nend;\r\n\r\nprocedure TSyntaxLine.ReportSyntaxError(const Msg: string);\r\nvar\r\n  LineInfo, CharInfo, LocInfo: string;\r\nbegin\r\n  // Build detailed error information using the current line, character, and position.\r\n  LineInfo := 'Line: ' + GetCurrentLine;\r\n  CharInfo := 'Character: ' + FSourceText[FCurrentPos];\r\n  LocInfo := 'Position: (' + FLineColumn.X.ToString + ', ' + FLineColumn.Y.ToString + ')';\r\n\r\n  // Display the error message along with the error details.\r\n  MessageDlg(\r\n    Msg + sLineBreak + sLineBreak +\r\n    LineInfo + sLineBreak +\r\n    CharInfo + sLineBreak +\r\n    LocInfo,\r\n    mtError, [mbOK], 0\r\n  );\r\n  // Abort the program execution after reporting the error.\r\n  Abort;\r\nend;\r\n\r\nend.\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/SyntaxLine.pas b/SyntaxLine.pas
--- a/SyntaxLine.pas	(revision e83c5b67b6624f4db1f9e64c15c5bf7be7aa9c19)
+++ b/SyntaxLine.pas	(date 1740231564239)
@@ -546,3 +546,7 @@
 
 end.
 
+                     
+                     
+                     
+                     
\ No newline at end of file
